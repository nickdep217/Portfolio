Nick Depies
Liam Mathes
Cesar Monsalud
Keith Bevans

CS225 Final Project Write Up

Users who use Facebook, Instagram, and other forms of social communication are always looking to connect with others. As a result, social media companies are constantly making new features to help their users find and connect with other people. In our project, we built the backend of 3 features that we thought could possibly benefit the user of a social media platform.  The features we built include a User Search feature, a Mutual Connection Finder, and a User Centrality Ranker. All 3 of these features can be interacted with in an easy terminal User Interface that we made.  While our functions could be used with any undirected graph, provided data was loaded properly. The database we used was the Stanford git-musae database. This data consists of approximately 37,000 nodes and 289,000 undirected edges. 

We created 3 functions to achieve our main goal of providing tools to help users. The first was a user search.  This algorithm uses Breadth first traversal to iterate through all of the users connected directly and indirectly to the starting user . If the user satisfies the search criteria that we define, they are added to a vector of User pointers which is returned at the end of the traversal.  The user data can then print functions to the terminal interface for the user to see.  While each user in our program had very limited data, in a real world application the user could change the criteria of the search function inside the Breadth first traversal to return all of the users you are somehow connected to that are in the same industry, share a similar location or have similar hobbies.  Our second function we created was a mutual connection finder. The objective of this function is to return the users that form a connection between the two selected users in the shortest path. This algorithm could be a tool that users could use for networking. Say there is a specific person they would like to get to know: the feature could figure out what people you might be able to network with to eventually meet the target person.  Our third function we created was a betweenness centrality ranker. Betweenness centrality measures the extent to which a vertex lies on paths between other vertices. In simple terms, centrality could be seen as a measure of a user's importance to the network. A user with a high betweenness centrality is a user that helps to bridge gaps between different groups of users that are otherwise not closely connected. The objective of creating this feature was to possibly provide users with some quantitative value for their importance to the network that is not just the number of connections or followers. 

Before we could begin to work on creating our main features, we had to build the classes for our network and create a function to populate our network. To build the network we created a public class called User which we used to hold and manage the data for each User and then a Network class to manage all of the instances of User that we created.  After setting up the classes, we built out our populate tree function. As you can see, our data was stored in two different files: one containing the username corresponding to each user ID and one containing the edges as represented by two user IDs separated by a comma. To read in our data in a time efficient manner we started by creating an instance of User for each username and adding it to an unnordered_map which mapped the users ID to a pointer to the User Object.  To add all of the edges to the users we created we used the unnordered_map to access each user that corresponded to the ID we had been given in O(1) amortized time for each edge. 

For BFS username, it is pretty obvious that BFS was used.  We implemented this for the user to be able to search for a username within our map of users.  It takes in a string provided by the user in our user interface, and returns a vector of usernames that start with the string.  This is useful because it allows for users to see some similarity because of names. In other words, it is just another way for users to find more useful connections with others.  To find these names, we use a BFS search to find the users.  During this bfs search, we used pseudo code implemented with our helper functions as shown in blue in the picture. The worst case time complexity is O(V+E).  

To develop our shortest path finder, we used Dijkstra's algorithm. The idea of Dijkstra’s algorithm is to iterate through nodes and determine each node's shortest distance from the starting point and keep going until the destination is reached. The main reason that we chose this algorithm is that it is faster compared to other algorithms. This is in part because it does not need to visit every node in the graph. By using the priority queue, once the desired edge is at the front of the queue, a shortest path has been found.  While popping and adding to the priority queue, the algorithm kept track of the distance from the start of each node as well as  each node's previous node that was the shortest distance from the starting point. Both of these things were kept track of using Unordered maps to optimize the time complexity of the function.  After reaching the destination in the queue, the algorithm uses  the mapping to the previous node to reconstruct the path that the node traveled.

Before talking about how we implemented our betweenness centrality algorithm, let's review what betweenness centrality is. Betweenness centrality is a measure of the extent to which a vertex lies on paths between other vertices. As a result, centrality can be used as an indicator of a vertex's importance to efficiently connecting a network. Furthermore, a user with a high betweenness centrality is one that not only has a lot of connections, but connects people that would otherwise not be closely connected. Betweenness centrality can be calculated by dividing all of the shortest paths between every pair of vertices in a graph that pass through the selected vertex by the total number of shortest paths between every pair of vertices in the graph. 

As you have to find all of the shortest paths through every pair of vertices in a graph, calculating the betweenness centrality can be very time consuming, especially in a big graph. For example, in our data set which has approximately 37,000 data points, there are approximately 684 million pairs of vertices. To avoid finding every shortest path for each node we created an algorithm that will find an estimation of the betweenness centrality by calculating the centrality using a subset of the data. To help us find a subset of the nodes to make an approximation of centrality, we created a helper function called get_connection_level() which returns a vector containing all of the nodes at a specified depth. To do this, the algorithm uses a spin off of a breadth first traversal with a specified depth. For example, if we specified the depth to be 2 and the central node to be 0, the program would return the orange and yellow nodes.

After specifying the depth of the approximation and getting a vector containing all of the nodes that we will be factoring into the betweenness centrality estimate, the program will iterate through every pair of user nodes that can be formed from the nodes that we are using. On each pair of nodes the program will call the Paths_through_Node function which will return a pair of ints that contains the number of shortest paths which pass through the central node and the number of total shortest paths between the nodes. 

After finishing calculating the number of paths for each pair of nodes the result of all the nodes are summed up. The code highlighted in the red box is the iteration and summation of all of the shortest paths and shortest paths through nodes. After this is done we multiply this number by a normalization constant which will make all values of centrality between the 0-10000 range with most scores falling between 0-200. This score can be compared to other users centrality scores to help a user determine their importance to the network as well as the importance of other nodes. 

The User Interface is accessible through the terminal and has been optimized with readability in mind. Users can select an option from the presented list by typing out the option and entering the value.  To test our functions we used a test data set which is pictured in this slide. We manually made calls to our helper functions and our main functions to make sure that they had the correct output. When running our program you can choose to run the test dataset or the full real dataset. When running the test dataset you can check your outputs using this graph.

Our leading question:  How can we provide additional data to help a user examine their position in  a social network?  To answer our leading question, we set three goals.  An algorithm that uses BFS to search for users, Dijkstra’s Algorithm to find connections, and a centrality ranker.  In conclusion, we are able to help a user determine their connections and where they stand mutually with respect to fellow users.  With our user being able to search through users, and get out information such as connections, they will be able to look through data to determine what connections they should potentially make. 
